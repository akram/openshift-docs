// Module included in the following assemblies:
//
// * images/using_images/images-other-jenkins.adoc

[id="images-other-jenkins-permissions_{context}"]
= Jenkins permissions

If in the ConfigMap the `<serviceAccount>` element of the Pod Template XML is
the {product-title} Service Account used for the resulting Pod,  the service
account credentials mounted into the Pod, with permissions associated with the
service account, control which operations against the {product-title} master are
allowed from the Pod.

Consider the following with service accounts used for the Pod, launched by the
Kubernetes Plug-in running in the {product-title} Jenkins image:

If you use the example template for Jenkins provided by {product-title}, the
`jenkins` service account is defined with the `edit` role for the project
Jenkins is running in, and the master Jenkins Pod has that service account
mounted.

The two default Maven and NodeJS Pod Templates injected into the Jenkins
configuration are also set to use the same service account as the master.

* Any Pod Templates auto-discovered by the OpenShift Sync plug-in as
a result of imagestreams or imagestreamtags having the required label or
annotations have their service account set to the master's service account.
* For the other ways you can provide a Pod Template definition into Jenkins and
the Kubernetes plug-in, you have to explicitly specify the service account to
use.
* Those other ways include the Jenkins console, the `podTemplate` pipeline DSL
provided by the Kubernetes plug-in, or labeling a ConfigMap whose data is the
XML configuration for a Pod Template.
* If you do not specify a value for the service account, the `default` service
account is used.
* You need to ensure that whatever service account is used has the necessary
permissions, roles, and so on defined within {product-title} to manipulate
whatever projects you choose to manipulate from the within the Pod.
